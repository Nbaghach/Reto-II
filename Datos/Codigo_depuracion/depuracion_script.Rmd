---
title: "Reto 1 modulo 8"
output: html_document
date: "2025-08-03"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


3.1 Paquetes y rutas del proyecto
```{r}
# Paquetes
if (!requireNamespace("readr", quietly = TRUE)) install.packages("readr")
if (!requireNamespace("dplyr", quietly = TRUE)) install.packages("dplyr")
if (!requireNamespace("here",  quietly = TRUE)) install.packages("here")

library(readr)
library(dplyr)
library(here)

# Rutas relativas (NO usar rutas absolutas)
base    <- here("Datos", "Base_de_datos_original")
out_dir <- here("Datos", "Base_de_datos_depurada")

# Comprobación rápida: archivos esperados en la carpeta original
print(list.files(base))
stopifnot(file.exists(file.path(base, "ddf--entities--geo--country.csv")))
stopifnot(file.exists(file.path(base, "ddf--datapoints--immigrant_stock--by--geo--year.csv")))
stopifnot(file.exists(file.path(base, "ddf--datapoints--emigrant_stock--by--geo--year.csv")))
```

3.2 Importación de datos crudos
```{r}
# Lectura (UTF-8) de los tres CSV originales
entities_geo <- read_csv(file.path(base, "ddf--entities--geo--country.csv"),
                         locale = locale(encoding = "UTF-8"),
                         show_col_types = FALSE)

immigrant_df <- read_csv(file.path(base, "ddf--datapoints--immigrant_stock--by--geo--year.csv"),
                         locale = locale(encoding = "UTF-8"),
                         show_col_types = FALSE)

emigrant_df  <- read_csv(file.path(base, "ddf--datapoints--emigrant_stock--by--geo--year.csv"),
                         locale = locale(encoding = "UTF-8"),
                         show_col_types = FALSE)

# Vistazo
dplyr::glimpse(entities_geo)
dplyr::glimpse(immigrant_df)
dplyr::glimpse(emigrant_df)
```

3.3 Limpieza y estandarización
```{r}
# 1) Detectar clave (geo/country) y columna de nombre legible (name / name:en)
key_col  <- if ("country" %in% names(entities_geo)) "country" else "geo"
name_col <- if ("name" %in% names(entities_geo)) "name" else if ("name:en" %in% names(entities_geo)) "name:en" else NA_character_

entities_geo_clean <- entities_geo %>%
  transmute(
    geo_key = .data[[key_col]],
    country_name = dplyr::coalesce(.data[[name_col]], as.character(.data[[key_col]]))
  )

# 2) Preparar inmigración (stock por país-año) y añadir nombre de país
imm <- immigrant_df %>%
  mutate(year = as.integer(year)) %>%
  left_join(entities_geo_clean, by = c("geo" = "geo_key")) %>%
  rename(immigrant_stock_value = immigrant_stock) %>%
  select(geo, year, country_name, immigrant_stock_value)

# 3) Preparar emigración (stock por país-año) y añadir nombre de país
emi <- emigrant_df %>%
  mutate(year = as.integer(year)) %>%
  left_join(entities_geo_clean, by = c("geo" = "geo_key")) %>%
  rename(emigrant_stock_value = emigrant_stock) %>%
  select(geo, year, country_name, emigrant_stock_value)

# 4) Guardar intermedios
readr::write_csv(imm, file.path(out_dir, "immigrant_stock_by_country_year.csv"))
readr::write_csv(emi, file.path(out_dir, "emigrant_stock_by_country_year.csv"))

```

3.4 Cálculo de migración neta y depuración de duplicadas
```{r}
# 5) Unir inmigración y emigración y calcular migración neta
net_mig <- full_join(imm, emi, by = c("geo", "year", "country_name")) %>%
  mutate(
    immigrant_stock_value = as.numeric(immigrant_stock_value),
    emigrant_stock_value  = as.numeric(emigrant_stock_value),
    net_migration = immigrant_stock_value - emigrant_stock_value
  )

# Guardar versión base (antes de limpiar duplicadas derivadas de otros metadatos)
readr::write_csv(net_mig, file.path(out_dir, "migracion_neta_por_pais_ano.csv"))

# 6) Si el join arrastró columnas duplicadas tipo *.x / *.y (por meter metadatos),
#    las limpiamos y removemos iso3166_2, que viene vacío.
net_mig_clean <- net_mig %>%
  # eliminar todas las columnas que terminan en .y (duplicadas)
  select(-matches("\\.y$")) %>%
  # quitar el sufijo .x del resto de columnas duplicadas
  rename_with(~ sub("\\.x$", "", .x), ends_with(".x")) %>%
  # eliminar iso3166_2 si está presente (vacía habitualmente)
  select(-any_of(c("iso3166_2", "iso3166_2.x", "iso3166_2.y"))) %>%
  arrange(geo, year)

# Guardar versión limpia definitiva para análisis
readr::write_csv(net_mig_clean, file.path(out_dir, "migracion_neta_limpio.csv"))

```

3.5 Registro de salidas
```{r}
message(" Archivos creados en: ", normalizePath(out_dir))
print(list.files(out_dir))
```




